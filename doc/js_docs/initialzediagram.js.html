<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: initialzediagram.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: initialzediagram.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>////////////////////////
// initialize_diagram //
////////////////////////
/**
 * Sets up the diagram's graph, paper, and controllers.
 * @class initialize_diagram
 */

/**
 * This initializes the local graph to empty, and stores it in the collaborative
 *   graph. Essentially, this should only be called when the document is first
 *   created. However, it can potentially be used to "reset" the diagram to
 *   empty.
 * @preconditions colGraph exists and has access to the collaborative graph.
 * @postconditions the local graph and collaborative graph are both empty
 * @memberOf initialize_diagram
 */
function initializeGraph() {
	graph = new joint.dia.Graph;
	colGraph.graph = JSON.stringify(graph);
}

/**
 * Initializes the graph used for printing to whatever is in the current
 *   editable graph. The print graph is not directly linked to the collaborative
 *   graph and is only updated at the time of printing so that the graph can not
 *   be changed as you are printing it.
 * @preconditions graph exists.
 * @postconditions printGraph contains the contents of graph.
 * @memberOf initialize_diagram
 */
function initializePrintGraph(){
	printGraph = new joint.dia.Graph;
	console.log("Print graph created.");
	printGraph.fromJSON(JSON.parse(JSON.stringify(graph)));
}

/**
 * Updates the print graph with the contents of graph.
 * @preconditions printGraph and graph exist.
 * @postconditions printGraph has the same contents of graph.
 * @memberOf initialize_diagram
 */
function updatePrintGraph(){
	printGraph.fromJSON(JSON.parse(JSON.stringify(graph)));
}
	
/**
 * Removes all of the selection boxes from the screen
 * @preconditions The program has been initialized and a document opened
 * @postconditions All selection boxes are removed from the screen
 * @memberOf initialize_diagram
 */
function removeAllSelectionBoxes() {
	var svg = $.find("svg")[0];
	
	// remove all of the current selection boxes from the screen
	var selectionBoxes = $(".selectionBox");
	for (var i = 0; i &lt; selectionBoxes.length; i++) {
		selectionBox = selectionBoxes[i];
		svg.removeChild(selectionBox);
	}
}

/**
 * Draws a selection box across certain coordinates
 * @param  {int} startX starting x position of the box
 * @param  {int} startY starting y position of the box
 * @param  {int} endX   ending x position of the box
 * @param  {int} endY   ending y position of the box
 * @preconditions The document is initialized
 * @postconditions A box is draw from startX and startY to endX and endY
 * @memberOf initialize_diagram
 */
function drawSelectionBox(startX, startY, endX, endY) {
	// delete all previous selection boxes
	$(".selectionBox").remove();

	// get the main canvas
	var svg = $.find("svg")[0];
	
	var box = document.createElementNS("http://www.w3.org/2000/svg", 'rect'); //Create a path in SVG's namespace
	box.setAttribute("class", "selectionBox");

	// translate coordinates to match the paper position
	startX += paperOffsetX;
	endX += paperOffsetX;
	startY += paperOffsetY;
	endY += paperOffsetY;

	// scale to the current paper size
	startX *= paperScale;
	startY *= paperScale;
	endX *= paperScale;
	endY *= paperScale;

	// smart rect deals with negative widths/heights automagically
	var rect = smartRect(startX, startY, endX, endY);

	box.setAttribute("x", rect.x);
	box.setAttribute("y", rect.y);
	box.setAttribute("width", rect.width);
	box.setAttribute("height", rect.height);

	box.style.fill = "#55cecc";
	box.setAttribute("fill-opacity", "0.4");
	svg.appendChild(box);
}

/**
 * This initialzes the local "paper" object from joint.js to be able to display
 *   the diagram.
 * @preconditions The local graph must exist. The HTML container "paperView"
 *   must exist.
 * @postconditions The html container div "paperView" will hold a view of the
 *   diagram, representing the back-end model.
 * @memberOf initialize_diagram
 */
function initializePaper() {
	paper = new joint.dia.Paper({
		el: $('#paperView'),
		width: 1000,
		height: 1000,
		model: graph,
		perpendicularLinks: true,
		gridSize: 1
	});

	paperScale = 1;
	paperOffsetX = 0;
	paperOffsetY = 0;

	paper.on('blank:pointerdown', paperEmptySelectionPressed);
	paper.$el.on('wheel', paperZoom);
	paper.$el.on('mouseup', paperOnMouseUp);
	addEvent(window, 'mouseup', stopDraggingAction);
	addEvent(window, 'resize', resizePaper);
	resizePaper();
	
	// First, unembed the cell that has just been grabbed by the user.
	paper.on('cell:pointerdown', bringParentlessCellToFront);
	paper.on('cell:pointerdown', deParentCell);
	
	paper.on('cell:pointerup', parentCell);	
	paper.on('cell:pointerup', selectClickedCell);
	paper.on('blank:pointerclick', deselectCell);
	
	paper.on('cell:pointerup', dropEdge);
	graph.on('change', function(cell) { 
		if (isCollabRecordingAllowed()) {
			selected[0] = cell;
			updateProperties();
		}
		
	});

	// initialize the variables used to hold the starting drag location
	boxSelectionX = null;
	boxSelectionY = null;
	initializeView();

}


/**
 * Initializes all the views used for drag resizing.
 * @preconditions The classes each view is for must already be defined.
 * @postconditions The views are initialized
 * @memberOf initialize_diagram
 */
function initializeView(){
	initializeStockView();
	initializeImageNodeView();
	initializeTextView();
	initializeAgentView();
	initializeStateView();
	initializeTerminalStateView();
	initializeBranchView();
	initializeVariableView();
	initializeParameterView();
}



/**
 * This initialzes the local "paper" object that is used for printing purposes
 *   from joint.js to be able to display the diagram.
 * @preconditions The printPraph must exist. The HTML container "printView" must
 *   exist.
 * @postconditions The html container div "printView" will hold a hidden view of
 *   the diagram, representing the back-end model.
 * @memberOf initialize_diagram
 */
function initializePrintPaper() {
	//Paper is initialized with 0 height and width so it does not take up space
	//until it is needed for printing
	printPaper = new joint.dia.Paper({
		el: $('#printView'),
		width: 1,
		height: 1,
		model: graph,
		perpendicularLinks: true,
		gridSize: 1
	});
	printPaper.scale(1,1);	
}

/**
 * On mouse wheel over the "paper", zoom based on mouse wheel direction.
 * @preconditions The "wheel" event has triggered, and contains a non-zero
 *   number for direction of mouse wheel.
 * @postconditions Scales if paperScale > 0.1. Prevents scrolling on page when
 *   happens.
 * @invariant The zoom will override default zoom functionality
 * @param  {event} e the triggering wheel event
 * @memberOf initialize_diagram
 */
function paperZoom(e) {
	
	var oldPaperScale = paperScale;
	
	//For cross browser use, grab the direction the mouse wheel has turned
	var delta = Math.max(-1, Math.min(1, (-e.originalEvent.deltaY || e.originalEvent.wheelDelta || -e.originalEvent.detail)));
	//If the mouse wheel rolled "down", zoom out
	if (delta > 0) {
		paperScale += 0.1;
	}
	//If the mouse wheel rolled "up", zoom out
	else if (paperScale > 0.2){ //The value is 0.2 because the objects disappear if it is 0.1
		paperScale -= 0.1;
	}

	//Set the actual zoom
	paper.scale(paperScale, paperScale);
	
	//Reposition the origin to keep the upper left corner where it is
	var xOffset = paper.options.origin.x;
	var yOffset = paper.options.origin.y;
	paper.setOrigin(xOffset * (paperScale / oldPaperScale), yOffset * (paperScale / oldPaperScale));
	

	//Prevent the mouse wheel event from scrolling
	e.originalEvent.preventDefault();
}	
		

/**
 * Removes paper interation
 * @preconditions the paper must exist
 * @postconditions the user will no longer be able to interact with the paper
 * @memberOf initialize_diagram
 */
function removePaperInteraction() {
	selected = {};
	paper.$el.addClass("nonInteractive");
}

/**
 * This restores the user's ability to interact with the paper.
 * @preconditions the paper must exist
 * @postconditions the user will once more be able to interact with the paper
 * @memberOf initialize_diagram
 */
function restorePaperInteraction() {
	paper.$el.removeClass("nonInteractive");
}

/**
 * Resizes the paper based on the window size
 * @param  {undefined} e placeholder for joint.js
 * @preconditions the document is initialized, has a paperView element, window
 *   is initalized.
 * @postconditions the paper is resized
 * @memberOf initialize_diagram
 */
function resizePaper(e) {
	var paperDiv = document.getElementById('paperView');
	var heightOfPaper = window.innerHeight - 250;
	if (heightOfPaper &lt; 450) {
		heightOfPaper = 450;
	}
	paper.setDimensions(window.innerWidth - 275, heightOfPaper);
	
}


/**
 * Resizes the printing paper so that it fits a sheet of paper and scales the
 *   content so that it all fits inside the paper.
 * @param  {undefined} e placeholder for joint.js
 * @preconditions the paper is initialized
 * @postconditions the print paper is resized to 1000x1250
 * @todo  Remove magic numbers
 * @memberOf initialize_diagram
 */
function resizePrintPaper(e){
	//The values 1000 and 1250 make the paper fit the print page nicely
	var width = 1000;
	var height = 1250;
	printPaper.setDimensions(width, height);
	printPaper.scaleContentToFit();
}

/**
 * Shrinks the paper so that it no longer takes up space. This is done after
 *   printing is complete. This is required because the paper has a visibility
 *   of hidden, not a display of none. The paper can not have a display of none
 *   because there is an issue where the size of objects is changes when the
 *   paper goes from no display to block display.
 * @param  {undefined} e placeholder for joint.js
 * @preconditions The printPaper must exist.
 * @postconditions the printPaper will be the smallest possible size.
 * @memberOf initialize_diagram
 */
function shrinkPrintPaper(e){
	//Values are 1 and 1 because using 0 and 0 does not work
	var width = 1;
	var height = 1;
	printPaper.setDimensions(width, height);
}
	

/**
 * Trigger when the user has clicked on an empty part of the paper. At the
 *   moment it then triggers the "panning" functionality, and updates where the
 *   mouse is.
 *
 * Later, our plans are to divide the functionality of this function into "pan
 *   when the user is also pressing a pan button" and "start multi selection"
 * @preconditions The user's mouse is over the paper in an empty part of the
 *   paper. The event actually happened.
 * @postconditions The user's mouse position has been recorded, and the
 *   "panning" functionality is activated.
 * @param  {event} e the click event which triggered the function call
 * @memberOf initialize_diagram
 */
function paperEmptySelectionPressed(e) {
	console.log("The mouse was clicked in an empty paper location");
	updateMousePos(e);
	
	// if the alt key is down, then initiate panning
		movingViewPort = true;
		console.log("Panning of the paper has been initiated");
	
	// otherwise start rectangle selection
	// else {
	// 	console.log("Box selection has been initiated");
	// 	boxSelectionX = curMousePos.x;
	// 	boxSelectionY = curMousePos.y;
	// }
	
	deselectAllCells();
}


/**
 * When the user lets go of the mouse over the paper, call this function. Based
 *   on previous state logic, this function decides how to handle said mouse
 *   event
 *
 * Possible ways of handling it currently only include creating an object based
 *   on user button selections At the end of the function, it resets the UI
 *   selections and resets the global state to "EDIT" mode.
 * @preconditions The user's mouse is over the paper. The mouseup event actually
 *   triggered.
 * @postconditions The user's mouse position on the paper has been updated. The
 *   internal logic has handled any object creation. The internal state has been
 *   reset to "EDIT" mode.
 * @param  {event} e the event which triggered the function call
 * @memberOf initialize_diagram
 */
function paperOnMouseUp(e) {
	updateMousePos(e)

	// TODO refactor into a switch???
	if (genUI.lastClickedValue == "Stock") {
		createStock(curMousePos);

	} else if (genUI.lastClickedValue == "State") {
		createState(curMousePos);
		
	} else if (genUI.lastClickedValue == "Final State") {
		createFinalState(curMousePos);
		
	} else if (genUI.lastClickedValue == "Branch") {
		createBranch(curMousePos);
		
	} else if (genUI.lastClickedValue == "Agent") {
		createAgent(curMousePos);
		
	} else if (genUI.lastClickedValue == "Intervention") {
		createIntervention(curMousePos);
		
	} else if (genUI.lastClickedValue == "Text Area") {
		createText(curMousePos);
		
	} else if (genUI.lastClickedValue == "Transition") {
		createTransition(curMousePos);
		
	} else if (genUI.lastClickedValue == "Connection") {
		createConnection(curMousePos);
		
	} else if (genUI.lastClickedValue == "Image") {
		createImage(curMousePos);
		
	} else if (genUI.lastClickedValue == "Variable") {
		createVariable(curMousePos);
		
	} else if (genUI.lastClickedValue == "Parameter"){
		createParameter(curMousePos);
		
	} else if (genUI.lastClickedValue == "Flow"){
		createFlow(curMousePos);
	} else {
		console.log(genUI.lastClickedValue);
	}

	genUI.deselectUIElements();
	genUI.lastClickedValue = "EDIT"; // reset the cursor back to editing
	movingViewPort = false;
	deselectAllCells();
}

/**
 * Selects a cell that has been clicked
 * @param  {view} cellView a view onto the cell
 * @param  {undefined} evt      placeholder for joint.js
 * @preconditions cellView has an initialized model, the document is created,
 *   the paper has been created
 * @postconditions a clicked cell is selected
 * @memberOf initialize_diagram
 */
function selectClickedCell(cellView, evt) {
	
	bringChildrenOfParentToFront(cellView.model);
	selected[0] = cellView.model;

	updateProperties();

	// select the cell
	var cell = selected[0];
	var view = cell.findView(paper);
	view.highlight();


}

/**
 * Deselected a cell
 * @preconditions A cell is currently selected
 * @postconditions A cell is no longer selected
 * @memberOf initialize_diagram
 */
function deselectCell() {

   if (selected.length > 0) {
       selected[0].setSelected(false); 
   }
   
   selected = {};
   updateProperties();
}


/**
 * When the user hits a key, check which key was pressed. Handle state
 *   accordingly.
 *
 * Currently, the only key this function accounts for is the "delete key". Works
 *   on both Windows and Mac. However, further functionality planned includes
 *   adding a "when panning key has been pressed", among others
 * @preconditions "keyDown" event has fired with a valid, non empty keyCode.
 * @postconditions The "keyDown" key has been checked, and any behaviour
 *   associated with that key have been dispatched. Current behaviour dispatch
 *   includes: "Delete Key": Delete currently selected node.
 * @param  {event} e The user hitting the key event which triggered the function
 *   call.
 * @memberOf initialize_diagram
 */
function handleKeyInput(e) {
	if (e.keyCode == 46) {
		deleteSelectedCell(e);
	}
}


/**
 * Deletes the currently selected node, as well as ensures other collaborators
 *   have the node deleted as well.
 * @preconditions There should be some cell at index 0 of "selected" for
 *   something to happen. However, if there is not, nothing happens.
 * @postconditions Whatever cell was at index 0 of selected has been removed
 *   from the graph and view. The removed cell is also removed from the
 *   "selected" array, and everything in the selected array is shifted one down.
 * @param  {event} e Event that trigger the function call.
 * @memberOf initialize_diagram
 */
function deleteSelectedCell(e) {
	if (selected){
		if (selected[0]) {
			rootModel.getRoot().get(selected[0].id).action = 'remove';
			selected[0].remove();
		}
	}
}

/**
 * If something is being dragged, stop dragging it
 * @preconditions The document is initialized
 * @postconditions Nothing is dragged is the mouse moves
 * @memberOf initialize_diagram
 */
function stopDraggingAction() {
	console.log("A drag has stopped");
	// if we were panning, stop the panning
	if (movingViewPort) {
		movingViewPort = false;
		console.log("Panning has stopped");

	// otherwise we need to end a box selection
	} else if (boxSelectionX != null) {
		//deselect all of the previously selected cells
		deselectAllCells();

		var curX = curMousePos.x;
		var curY  = curMousePos.y

		var rect = smartRect(boxSelectionX, boxSelectionY, curX, curY);

		var enclosed = paper.findViewsInArea(rect);
		for (var i = 0; i &lt; enclosed.length; i++) {
			enclosed[i].highlight();
		}

		// clear the property box
		$$("propertiesFormId").reconstruct();

		// remove all drawn selection boxes
		$(".selectionBox").remove();

		// reset the box selection start values
		boxSelectionX = null;
		boxSelectionY = null;
		console.log("Box selection has stopped");
	}
}

/**
 * Takes whatever cells are selected and deselects them
 * @preconditions the graph is initialized, the cellView exists
 * @postconditions nothing is selected
 * @invariant 0 or more cells are selected at any time
 * @history the number of cells goes to 0 regardless of what it was at before
 * @memberOf initialize_diagram
 */
function deselectAllCells() {
	var cells = graph.getCells();
	for (var i = 0; i &lt; cells.length; i++) {
		// currently cells refers to the data object of each cell
		// we need to find the view associated with the data
		var cellView = cells[i].findView(paper);
		cellView.unhighlight();
	}

	selected = [];
}

/**
 * When the mouse moves, handle the logic of figuring out what further methods
 *   need to be dispatched.
 *
 * Currently, this logic is limited to when the user is panning the view of the
 *   diagram. Planned changes include handling of "click-and-drag" to select
 *   multiple objects at once.
 * @preconditions A mouseMove event has fired off with the valid "x" and "y"
 *   position of the mouse.
 * @postconditions The appropriate behaviour has been dispatched based off what
 *   the global internal-state is. This behavious currently handles: panning of
 *   the diagram view.
 * @param  {event} e The mouse moving event that triggered the function call.
 * @memberOf initialize_diagram
 */
function handleMouseMove(e) {
	var highlightedCount = getHighlightedItems().length;

	if (movingViewPort) {
		moveViewPort(e);

	// if we are currently dragging a selection box, we need to update it
	} else if (boxSelectionX != null) {
		updateMousePos(e);
		console.log("A box select is currently being dragged");
		drawSelectionBox(boxSelectionX, boxSelectionY, curMousePos.x, curMousePos.y);

	} 
	// else if ((highlightedCount > 1) &amp;&amp; e.buttons) {
	// 	updateMousePos(e);
	// 	moveSelectedItems();
	// }
}

/**
 * Takes the selected items and moves them with the mouse
 * @preconditions the graph is initalized
 * @postconditions items move linearly with the mouse
 * @memberOf initialize_diagram
 */
function moveSelectedItems() {
	var deltaX = curMousePos.x - oldMousePos.x;
	var deltaY = curMousePos.y - oldMousePos.y;

	var highlightedItems = getHighlightedItems();
	var cells = graph.getCells();

	for (var i = 0; i &lt; highlightedItems.length; i++) {
		var highlightedItem = highlightedItems[i];
		var htmlId = highlightedItem.getAttribute("model-id");

		for (var j = 0; j &lt; cells.length; j++) {
			var cell = cells[j];
			var modelId = cell.attributes.id;

			if (modelId == htmlId) {
				cell.translate(deltaX, deltaY);
			}
		}
	}

	selected[0].translate(-deltaX, -deltaY);
}

/**
 * This function checks where the mouse currently is, and where it used to be in
 *   relation to a position on the paper. It then alters the view of the diagram
 *   by that measurement.
 * @preconditions A mouseMove event has fired off with the valid "x" and "y"
 *   position of the mouse.
 * @postconditions curMousePos holds the current mouse position in relation to
 *   the diagram's new display position. oldMousePos holds the previous mouse
 *   position in relation to the diagram's new display position
 * @param  {event} e The event that triggered the function.
 * @memberOf initialize_diagram
 */
function moveViewPort(e) {
	updateMousePos(e);
	var origin = paper.options.origin;
	var deltaX = curMousePos.x - oldMousePos.x;
	var deltaY = curMousePos.y - oldMousePos.y;
	paper.setOrigin((deltaX * paperScale) + origin.x, (deltaY * paperScale) + origin.y);

	// save the paper translation
	paperOffsetX += deltaX;
	paperOffsetY += deltaY;

	updateMousePos(e);
}


/**
 * This function updates the current and previous mouse positions in relation to
 *   where it is in regards to the diagram. The previous mouse position will
 *   store what is the current mouse position prior to this function being
 *   called.
 * @preconditions A mouseMove event has fired off with the valid "x" and "y"
 *   position of the current mouse.
 * @postconditions curMousePos holds the current mouse position in relation to
 *   the diagram. oldMousePos holds the previous mouse position in relation to
 *   the diagram.
 * @param  {event} e The event that triggered the function call.
 * @memberOf initialize_diagram
 */
function updateMousePos(e) {
	oldMousePos = curMousePos;
	offset =  $('#paperView').offset();
	curMousePos = paper.clientToLocalPoint({ x: e.clientX, y: e.clientY });
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="cell_parent_logic.html">cell_parent_logic</a></li><li><a href="check_collab_allowed.html">check_collab_allowed</a></li><li><a href="collab_object_setup.html">collab_object_setup</a></li><li><a href="connection_check.html">connection_check</a></li><li><a href="create_objects.html">create_objects</a></li><li><a href="element_prop_alter.html">element_prop_alter</a></li><li><a href="g_r_api_auth.html">g_r_api_auth</a></li><li><a href="gen_ui.html">gen_ui</a></li><li><a href="initialize_diagram.html">initialize_diagram</a></li><li><a href="initialize_web_page.html">initialize_web_page</a></li><li><a href="link_joining.html">link_joining</a></li><li><a href="loading_bar.html">loading_bar</a></li><li><a href="qm_lab_file_opened.html">qm_lab_file_opened</a></li><li><a href="qm_lab_joint_classes.html">qm_lab_joint_classes</a></li><li><a href="utility_functions_qm_lab.html">utility_functions_qm_lab</a></li></ul><h3>Global</h3><ul><li><a href="global.html#dropEdge">dropEdge</a></li><li><a href="global.html#setInitialHTML">setInitialHTML</a></li><li><a href="global.html#setInitialHTMLBranch">setInitialHTMLBranch</a></li><li><a href="global.html#setInitialHTMLText">setInitialHTMLText</a></li><li><a href="global.html#startResizingTop">startResizingTop</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Apr 06 2016 22:53:53 GMT-0600 (Canada Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
